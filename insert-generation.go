package ulduar

import (
	"fmt"
	"reflect"
	"strings"
)

/*
	Basic Insert Sql Generation based of struct. Must add struct tags datapi so
	function knows what name of sql fields should be. If tableName parameter is not
	provided, then tableName is generated by snake casing struct name.
*/
func GenerateInsertSqlWithStruct(options *InsertOptions) (string, error) {
	t := reflect.TypeOf(options.Collection)
	if t == nil {
		return "", fmt.Errorf("error: InsertOptions.Collection cannot be nil")
	}

	table := getTableName(options.TableName, t.Name())

	v := reflect.ValueOf(options.Collection)
	columnNames := []string{}
	columnValues := []string{}

	for i := 0; i < t.NumField(); i++ {
		columnName := t.Field(i).Tag.Get("datapi")
		if columnName == "" {
			return "", fmt.Errorf("error: struct value %s does not possess `datapi` tags", t.Field(i).Name)
		} else if Contains(options.SkipColumnList, columnName) {
			continue
		}

		fieldType := v.Field(i).Type().String()
		fieldValue := v.Field(i).Interface()

		data, err := checkType(fieldValue, fieldType)
		if err != nil {
			return "", err
		}

		columnNames = append(columnNames, columnName)
		columnValues = append(columnValues, data)
	}

	columns := strings.Join(columnNames, ", ")
	values := strings.Join(columnValues, ", ")

	statement := fmt.Sprintf("INSERT INTO %s ( %s ) VALUES ( %s );", table, columns, values)

	return statement, nil
}
