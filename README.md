# ulduar

## What is 'ulduar'

This is a repository that attempts to make working with AWS DataAPI a bit easier. This package can be used as a basic ORM or as a very basic raw sql statement generator. This package is very much still a work in progress, but as time goes on, support for more complex queries will be implemented.

Please take note that majority of these functions that generate statements using structs/collections will require a struct tag named `datapi` to formulate the column names.

## Examples

### Set Up

```go
    api := ulduar.DataApi{
        RDSClient: {rdsClient},
        ResourceArn: {YourArn},
        SecretArn: {YourArn},
        Dbname: {YourDB},
    }
```

### Struct Tags

Ulduar uses the provided `datapi` struct tags as each struct field's column name. Below is an example.

```go
    type SomeStruct struct{
        SomeString string `datapi:"someString"`
        SomeInt int64 `datapi:"some_int"`
        SomeTime time.Time `datapi:"date"`
        SomeFloat float64 `datapi:"myNumber"`
    }
```

### Tables

```go
    // Create a table
    tableName := "test_table"
    err := api.CreateTable(&ulduar.Table{
        Options: &ulduar.TableOptions{
            Collection: SomeStruct{},
            TableName: &tableName,
        }
    })

    // Drop Table
    err := api.DropTable(&ulduar.Table{
        Options: &ulduar.TableOptions{
            Collection: SomeStruct{},
            TableName: &tableName,
        }
    })

    // Drop Tables
    tableNames := []string{"test_table", "test_table2"}
    err := api.DropTables(tableNames)
```

### Insert

```go
    // Most Basic
    // If TableName isn't provided, it is generated by snake-casing struct name.
    err := api.InsertRecord(&ulduar.Insert{
        Options: &ulduar.InsertOptions{
            Collection: SomeStruct,
        }
    })

    // Don't include every Struct field
    err := api.InsertRecord(&ulduar.Insert{
        Options: &ulduar.InsertOptions{
            Collection: SomeStruct,
            SkipColumnList: []string{"someString"},
        },
    })

    // Want a different name for your table?
    // Include TableName
    tableName := "my_custom_name"
    err := api.InsertRecord(&ulduar.Insert{
        Options: &ulduar.InsertOptions{
            Collection: SomeStruct,
            TableName: &tableName,
        },
    })

    // Inserting with generated dml sql template
    err := api.InsertDmlRecord(&ulduar.Insert{
        Options: &ulduar.InsertOptions{
            Collection: SomeStruct,
        },
    })
```

### Batch Insert

```go
    // If wanting to batch insert an array of varying structures
    err := api.BatchInsertRecords(&ulduar.InsertBatch{
		Options: []*ulduar.InsertOptions{
        {
			Collection:     SomeStruct,
		},
        {
			Collection:     SomeStruct2,
		}},
	})

    // Specify batch amount
    // This is the number of records sent per request
    batchAmount := 500
    err := api.BatchInsertRecords(&ulduar.InsertBatch{
		Options: []*ulduar.InsertOptions{
        {
			Collection:     SomeStruct,
		},
        {
			Collection:     SomeStruct2,
		}},
        BatchAmount: &batchAmount,
	})

    // If array structures don't change.
    err := api.BatchInsertWithSameDmlTemplate(&ulduar.InsertBatch{
		Options: []*ulduar.InsertOptions{
        {
			Collection:     SomeStruct,
		},
        {
			Collection:     SomeStruct2,
		}},
	})
```

### Update

```go
    // Basic Update
    condition := "id = 1"
    err := api.UpdateRecord(&ulduar.Update{
        Options: &ulduar.UpdateOptions{
            Collection: SomeStruct,
            Condition: &condition
        }
    })

    // Update with specified TableName
    tableName := "my_table"
    err := api.UpdateRecord(&ulduar.Update{
        Options: &ulduar.UpdateOptions{
            Collection: SomeStruct,
            Condition: &condition,
            TableName: &tableName,
        },
    })

    // Don't include each struct field
    tableName := "my_table"
    err := api.UpdateRecord(&ulduar.Update{
        Options: &ulduar.UpdateOptions{
            Collection: SomeStruct,
            Condition: &condition,
            SkipColumnList: []string{"someString", "date"},
        },
    })

    // Update using generated dml sql template
    err := api.UpdateDmlRecord(&ulduar.Update{
        Options: &ulduar.UpdateOptions{
            Collection: SomeStruct,
            Condition: &condition
        }
    })
```

### Batch Update

```go
    // If wanting to batch update an array of varying structures
    err := api.BatchUpdateRecords(&ulduar.UpdateBatch{
		Options: []*ulduar.UpdateOptions{
        {
			Collection:     SomeStruct,
		},
        {
			Collection:     SomeStruct2,
		}},
	})

    // Specify batch amount
    // This is the number of records sent with each request
    batchAmount := 200
    err := api.BatchUpdateRecords(&ulduar.UpdateBatch{
		Options: []*ulduar.UpdateOptions{
        {
			Collection:     SomeStruct,
		},
        {
			Collection:     SomeStruct2,
		}},
        BatchAmount: &batchAmount,
	})

    // If array structures don't change.
    err := api.BatchUpdateWithSameDmlTemplate(&ulduar.UpdateBatch{
		Options: []*ulduar.UpdateOptions{
        {
			Collection:     SomeStruct,
		},
        {
			Collection:     SomeStruct2,
		}},
	})
```

### Upsert

```go
    // Basic Upsert
    target := "some_column"
    err := api.UpsertRecord(&ulduar.Update{
        Options: &ulduar.UpdateOptions{
            Collection: SomeStruct,
            Target: &target
        },
    })

    // Specify table
    target := "some_column"
    table := "test"
    err := api.UpsertRecord(&ulduar.Update{
        Options: &ulduar.UpdateOptions{
            Collection: SomeStruct,
            Target: &target,
            TableName: &table,
        },
    })

    // If wanting to skip struct fields in initial INSERT statement
    // Ex. INSERT INTO x (...) VALUES (...)
    target := "some_column"
    err := api.UpsertRecord(&ulduar.Update{
        Options: &ulduar.UpdateOptions{
            Collection: SomeStruct,
            Target: &target,
            SkipColumnList: []string{"someString"},
        },
    })

    // Skip struct fields in UPDATE method on conflict
    // Ex. ON CONFLICT (target) DO UPDATE SET...
    target := "some_column"
    err := api.UpsertRecord(&ulduar.Update{
        Options: &ulduar.UpdateOptions{
            Collection: SomeStruct,
            Target: &target,
            NoUpdateList: []string{"date"},
        },
    })

    // Upsert using generated dml sql template
    target := "some_column"
    err := api.UpsertDmlRecord(&ulduar.Update{
        Options: &ulduar.UpdateOptions{
            Collection: SomeStruct,
            Target: &target,
        },
    })
```

### Batch Upsert

```go
    // If wanting to batch upsert an array of varying structures
    target1 := "date"
    target2 := "time"
    err := api.BatchUpsertRecords(&ulduar.UpsertBatch{
		Options: []*ulduar.UpsertOptions{
        {
			Collection:     SomeStruct,
            Target: &target1,
		},
        {
			Collection:     SomeStruct2,
            Target: &target2,
		}},
	})

    // Specify batch amount
    // This is the number of records sent per request
    batchAmount := 500
    err := api.BatchUpsertRecords(&ulduar.UpsertBatch{
		Options: []*ulduar.UpsertOptions{
        {
			Collection:     SomeStruct,
            Target: &target1,
		},
        {
			Collection:     SomeStruct2,
            Target: &target1,
		}},
        BatchAmount: &batchAmount,
	})

    // If array structures don't change.
    err := api.BatchUpsertWithSameDmlTemplate(&ulduar.UpsertBatch{
		Options: []*ulduar.UpsertOptions{
        {
			Collection:     SomeStruct,
            Target: &target1,
		},
        {
			Collection:     SomeStruct2,
            Target: &target1,
		}},
	})
```

### Delete

```go
    // Delete Basic
    tableName := "test"
    condition := "id = 1"
    err := api.DeleteRecord(&ulduar.Delete{
        Options: &ulduar.DeleteOptions{
            TableName: &tableName,
            Condition: &condition,
        },
    })

    // Delete more than 1 record
    condition1 := "id = 1"
    condition2 := "area = 'chubu'"
    err := api.DeleteRecords(&ulduar.DeleteBatch{
        Options: []*ulduar.DeleteOptions{
        {
            TableName: &tableName,
            Condition: &condition1,
        },
        {
            TableName: &tableName,
            Condition: &condition2,
        }
        },
    })
```

### Select

```go
    // Basic Select
    // Equivalent to SELECT * FROM some_struct
    record, err := api.QueryRecord(&ulduar.Select{
		Options: &ulduar.SelectOptions{
			Collection:     SomeStruct,
			SkipColumnList: []string{},
		},
	})

    // Specify table name
    // Equivalent to SELECT * FROM test
    tableName := "test"
    record, err := api.QueryRecord(&ulduar.Select{
		Options: &ulduar.SelectOptions{
			Collection:     SomeStruct,
			TableName: &tableName,
		},
	})

    // Add WHERE condition
    // Equivalent to SELECT * FROM some_struct WHERE area = 'chubu'
    filter := "area = 'chubu'"
    record, err := api.QueryRecord(&ulduar.Select{
		Options: &ulduar.SelectOptions{
			Collection:     SomeStruct,
			SkipColumnList: []string{},
            Filter: &filter,
		},
	})

    // Limit the number of records
    // Equivalent to SELECT * FROM some_struct LIMIT 10
    limit := 10
    record, err := api.QueryRecord(&ulduar.Select{
		Options: &ulduar.SelectOptions{
			Collection:     SomeStruct,
            Limit: &limit,
		},
	})

    // Sort Records
    // Equivalent to SELECT * FROM some_struct ORDER BY date DESC
    sortBy := "date"
    sortDirection := "DESC"
    record, err := api.QueryRecord(&ulduar.Select{
		Options: &ulduar.SelectOptions{
			Collection:     SomeStruct,
            SortByColumn: &sortBy,
            SortDirection: &sortDirection,
		},
	})

    // Specify columns (skip columns)
    // Equivalent to SELECT date FROM some_struct
    sortBy := "date"
    sortDirection := "DESC"
    record, err := api.QueryRecord(&ulduar.Select{
		Options: &ulduar.SelectOptions{
			Collection:     SomeStruct,
            SkipColumnList: []string{"someString", "myNumber", "some_int"}
		},
	})

    // Get record formatted in Json
    // Equivalent to SELECT * FROM some_struct
    record, err := api.QueryRecordJson(&ulduar.Select{
		Options: &ulduar.SelectOptions{
			Collection:     SomeStruct,
			SkipColumnList: []string{},
		},
	})
```

### Custom

```go
    // Executes provided sql statement
    sql := "INSERT INTO test (name, age) VALUES ('tom', 29);"
    err := api.CustomQuery(sql)
```

## Additional Functions

There are additional functions that each query builder uses internally that can be called individually. Most of these functions return the raw sql as a string. Below is a list of available functions.

```go
- GenerateDeleteDataSql(options *DeleteOptions) (string, error)
- GenerateDmlInsertSql(options *InsertOptions) (string, error)
- GenerateDmlUpsertSql(options *UpsertOptions) (string, error)
- GenerateDmlUpdateSql(options *UpdateOptions) (string, error)
- GenerateInsertSqlWithStruct(options *InsertOptions) (string, error)
- GenerateSqlParameters(options *SqlParamOptions) ([]types.SqlParameter, error)
- GenerateSelectSql(options *SelectOptions) (string, error)
- GenerateCreateTableSqlWithStruct(options *TableOptions) (string, error)
- GenerateDropTableSql(tableNames ...string) (string, error)
- GenerateUpdateSqlWithStruct(options *UpdateOptions) (string, error)
- GenerateUpsertSqlWithStruct(options *UpsertOptions) (string, error)
```

## Want to Support?

I am happy to accept any help from others. If you would like to help with the project, please feel free to create a pull request, but with each pull request, it is expected to have proper testing of each functionality. Any requests without any tests, will be denied.
