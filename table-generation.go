package ulduar

import (
	"fmt"
	"reflect"
	"strings"
)

/*
	Generates create table sql statement using provided struct. If tableName isn't provided, the
	name of the table will be generated by snake casing struct name. All types will
	be based off AWS Aurora PostgreSQL. All values will require `datapi` struct tags to identify
	name of column.
		int, int32, int64 == bigint
		float32, float64 == numeric
		string == text
		time.Time == timestamp with time zone
		bool == boolean
*/
func GenerateCreateTableSqlWithStruct(options *TableOptions) (string, error) {
	t := reflect.TypeOf(options.Collection) // Check if not nil
	if t == nil {
		return "", fmt.Errorf("error: TableOptions.Collection cannot be nil")
	}

	table := getTableName(options.TableName, t.Name())

	columnsMap := map[string]string{}
	cValue := reflect.ValueOf(options.Collection)

	for i := 0; i < t.NumField(); i++ {
		columnName := t.Field(i).Tag.Get("datapi")
		if columnName == "" {
			return "", fmt.Errorf("error: please check struct for proper 'datapi' struct tags")
		}

		fieldType := cValue.Field(i).Type().String()
		columnType, err := determineTableFieldType(fieldType)
		if err != nil {
			return "", err
		}

		columnsMap[columnName] = columnType
	}

	tableCmns := []string{"id SERIAL UNIQUE"}
	for columnName, columnType := range columnsMap {
		tableValue := fmt.Sprintf("%s %s", columnName, columnType)
		tableCmns = append(tableCmns, tableValue)
	}
	tableKey := fmt.Sprintf("CONSTRAINT %s_pkey PRIMARY KEY (id)", table)
	tableCmns = append(tableCmns, tableKey)

	tableColumns := strings.Join(tableCmns, ", ")

	sql := fmt.Sprintf("CREATE TABLE IF NOT EXISTS %s ( %s );", table, tableColumns)

	return sql, nil
}

func GenerateDropTableSql(tableNames ...string) (string, error) {
	if len(tableNames) == 0 {
		return "", fmt.Errorf("tableNames parameter cannot be empty")
	}

	return fmt.Sprintf("DROP TABLE %s", strings.Join(tableNames, ", ")), nil
}

/*
	Helper function that determines types of table columns based on their underlying type.
*/
func determineTableFieldType(fieldType string) (string, error) {
	switch {
	case strings.Contains(fieldType, "int"):
		return "bigint", nil
	case strings.Contains(fieldType, "float"):
		return "numeric", nil
	case fieldType == "bool":
		return "boolean", nil
	case fieldType == "string":
		return "text", nil
	case strings.Contains(fieldType, "time"):
		return "timestamp with time zone", nil
	}

	return "", fmt.Errorf("error: %s did not match any of the types", fieldType)
}
